# 백준 1105 팔
# 입력값의 범위 때문에 리스트 등을 사용하면 시간초과가 발생할 것 같음, 규칙을 찾아야 됨
# L <= n <= R 에서 8이 가장 적게 들어있는 수에서 8을 세는 프로그램
# 1 <= n <= 10 의 경우 8이 없는 수가 있으므로 0
# 88, 88의 경우 88밖에 없으므로 2
# 800, 899의 경우 8이 최소한 하나가 들어감 8XX~899 이므로 1
# 규칙을 유추해보면 자릿수가 바뀌는 경우는 무조건 0임, 즉, l과 r의 자릿수가 다르면 0
# 자릿수가 같더라도 l 혹은 r의 제일 앞자리에 8이 안 들어가면 0 (108, 809 의 경우 108다음 109부터 0이 되는 경우가 수두룩함)

# 간략하게 요약하면 길이와 앞자리만 확인하면 됨
# 길이도 다르고 앞자리도 다르면 8의 카운트는 0
# 길이는 같지만 앞자리가 다른 경우 예를 들어 80008, 88888의 경우
# 80009 같은 수가 있음, 즉 제일 앞자리 8다음 0, 8은 서로 다르므로 그 뒤는 볼 필요도 없다는 뜻
l, r = input().split()
a, b = len(l), len(r)
count = 0
if a != b:
    print(count)
else:
    for i in range(a):
        if l[i] != r[i]:
            break
        else:
            if l[i] == "8":
                count += 1
    print(count)