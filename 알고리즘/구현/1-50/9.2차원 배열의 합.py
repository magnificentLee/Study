# 이해하는데 시간이 상당히 걸린 문제
# 위에 주어지는 테이블은 기준 테이블
# 아래 주어지는 테이블은 위 테이블을 이용해 i,j 부터 x,y 까지의 합을 구하는 것
# 아래 테이블을 dp로 생각하고 테이블을 구성하면 시작이 1,1 부터이므로 n,0 / 0,m 의 값은 0이 된다
# dp는 i,j 부터 x,y 의 합이므로 1,1 = 1 / 1,2 = 1 + 2 = 3 / 1,3 = 1 + 2 + 4 = 7
# 2,1 = 1 + 8 = 9 / 2,2 = 1 + 2 + 8 + 16 = 27 / 2,3 = 1 + 2 + 4 + 8 + 16 + 32 = 63
# 1 2 4
# 8 16 32
#idx 0  1  2  3  (dp의 전체 크기, 어디까지나 i,j,x,y = 1,1,2,3 일때의 예시)
# 0  0  0  0  0
# 1  0  1  3  7
# 2  0  9 27 63 ...

n, m = map(int, input().split())

dp = [[0] * (m + 1) for _ in range(n + 1)]
num_table = [list(map(int, input().split())) for _ in range(n)]
k = int(input())

for i in range(1, n + 1):
    for j in range(1, m + 1):  # num 테이블은 0,0 부터 시작하지 않기 때문에 i - 1, j - 1
        # 상, 좌의 값을 구할때 중복으로 계산되기 때문에 dp[i - 1][j - 1] 의 값은 빼줘야됨
        dp[i][j] = num_table[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1]

for _ in range(k):
    i, j, x, y = map(int, input().split())
    # 겹치는 부분(dp[i][j - 1], dp[i - 1][j])은 빼주고 나머지 더해주기
    print(dp[x][y] - dp[x][j - 1] - dp[i - 1][y] + dp[i - 1][j - 1])


# 추가로 절대 브론즈1급으로 보이는 문제가 아님
# 최소 실버5로 보임
