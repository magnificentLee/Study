# 백준 1463 1로 만들기

# 시간 제한이 0.15초(파이썬3은 1.5초), 메모리 제한이 128MB 따라서 그리디로는 절대로 못 풀음
# 따라서 다이나믹 프로그래밍, 메모이제이션을 사용하자

# 이해하는데 좀 걸렸음
# 8 => 4 => 2 => 1
# 3    2    1  : count / i가 2로 나누어 떨어지면 i를 2로 나누어 떨어진 것에 +1을 해줌
# 4는 2로 나누어 떨어지므로 4를 2로 나눈 i = 2에서 +1을 해주면 2가 됨
# 마찬가지로 3도 적용 가능 ( 9 => 3 => 1)
# 하지만 반례 10이 있음
# 10 => 5 => 4 => 2 => 1
# 4     3    2    1 : count
# 10 => 9 => 3 => 1
# 3     2    1      : count
# 2로 나누면 4가 나오고 3으로 나누면 3이 나온다 이 경우는 어떻게 해야 될까?
# 최솟값으로 처리해보면
# 시작을 dp[i] = dp[i - 1] + 1 : 이전 값에 +1을 해준다음(10 <= 9 : 3 <= 2)
# if문으로 3, 2로 나누어 떨어지는 경우를 나눈 다음
# 최솟값으로, min(dp[i], dp[i // 3]), min(dp[i], dp[i // 3]) 으로 해주자

# 연산 방법은 총 세 가지
# 1. x가 3으로 나누어 떨어지면 3으로 나눔
# 2. x가 2로 나누어 떨어지면 2로 나눔
# 3. 1을 뺌
# 최종적으로 1을 만드는게 목표
n = int(input())
dp = [0] * (n + 1)  # 1이 목표값이기 때문에 1자체는 0, 2부터 시작임

for i in range(2, n + 1):
    dp[i] = dp[i - 1] + 1

    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i // 3] + 1)
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i // 2] + 1)
print(dp[n])