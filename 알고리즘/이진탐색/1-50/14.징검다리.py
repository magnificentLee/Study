# 백준 11561 징검다리
# 처음 생각했던 방식
# 최댓값을 구하는 방법은 tmp = 1~x까지 더한 값, n보다 작거나 같으면 x를 1씩 늘리고 최댓값을 x로 수정,
# n보다 커지는 순간에 반복문 종료, 최댓값을 출력
# 하지만 이렇게 하면 n의 값이 10^16 이기 때문에 시간초과가 발생할 것임

# 규칙을 찾아보자
# 최대의 수를 구하는 방법은 1부터 1씩 늘려가며 더하는 것임
# 예제의 100의 경우 13이 나오는데 이를 풀어보면
# 1~13, 1 2 3 4 5 6 7 8 9 10 11 12 13 순으로 늘어나는 것인데
# 이를 더해보면 1 3 6 10 15 21 28 36 45 55 66 78 91 번째에 다리가 있다는 것, 만약 14가 들어오면  105로 n을 초과하게 됨
# 따라서 78에서 22를 더하면 100이 된다. 하지만 갯수로 보면 결국에는 같음
# 쉽게 풀어보면 13의 등차수열의 합((13 * (13 + 1)) / 2)이라는 것임
# 즉, mid의 값을 start = 0, end = n 일 때 (start + end) // 2, mid 값을 늘려가며 mid의 등차수열 합이 n을 넘어가면 end 값을 줄이고
# 작거나 같으면 result를 최댓값으로 갱신해주며 start를 늘려가면(start = mid + 1) 빠르게 답을 찾을 수 있을 것임

# 1씩 늘어났을때가 최댓값이므로 mid의 등차수열을 이용하면 될 것


# 참고로 1e16 = 10000000000000000


def binary(n):
    start, end = 1, n
    result = 0
    while start <= end:
        mid = (start + end) // 2
        if (mid * (mid + 1)) // 2 <= n:
            result = mid
            start = mid + 1
        else:
            end = mid - 1
    return result


t = int(input())
for _ in range(t):
    n = int(input())
    print(binary(n))


# 블로그에서 발견한 시간 단축법
"""
# 등차수열의 합과 상한값을 이용하면 근의 공식으로 시간을 단축시킬 수 있음
# 등차수열의 합 = n(n + 1) / 2, 상한값 = 10^16 = 1e16
# 상한값 = n(n + 1) / 2 = 1e16, n(n + 1) = 2 * 1e16, n^2 + n - 2 * 1e16 = 0
# 즉, 상한값 max = n^2 + n - 2 * 1e16 = 0 에서 n의 값임
# 근의 공식 : ax^2 + bx + c = 0, x = (-b + sqrt(b^2 - 4 * a * c)) / 2 * a (n은 양수이기 때문에 +- 대신 +)
# (-1 + sqrt(b^2 - 4*(-2 * 1e16))) / 2
"""