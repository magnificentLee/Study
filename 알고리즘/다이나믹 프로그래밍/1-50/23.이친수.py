# dp 문제를 풀면서 항상 놓치는게 런타임에러임
# 예를 들어 dp = [0] * n, dp[0] = x, dp[1] = y 라고 작성하면 n = 1일 때 무조건 에러가 발생하는 것
# 이점에 항상 주의하자
# 규칙1. 이친수는 0으로 시작하지 않음
# 규칙2. 이친수에서는 1이 두 번 연속으로 나타나지 않음 : 1010, 1001 은 가능해도 1011 은 안 된다는것
# 1, 10, 100, 101, 1000, 1001, 1010, 10000, 10100, 10101, 10010, 10001 : 1, 1, 2, 3, 5
# 100000, 100001, 101000, 101010, 101001, 100100, 100101, 100010 : 8
# 규칙을 계산해본 결과 피보나치 수열과 동일한 것 같음
# append를 이용한 풀이1
"""
n = int(input())
dp = [1, 1]  # 한 자릿수 = 1 : 1, 두 자릿수 = 10 : 1...
for i in range(2, n):
    tmp = dp[i - 1] + dp[i - 2]
    dp.append(tmp)
print(dp[n - 1])
"""
# 치환을 이용한 풀이2
n = int(input())
a, b = 0, 1
for _ in range(n):
    a, b = b, a + b  # 두 줄로 하면 이번 계산에 바로 적용되므로 2^n을 구하는 식이 된다
print(a)