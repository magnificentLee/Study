# 2진법으로 풀어보면 알 수 있음
# 2진법으로 바꾼 다음 역순으로(최종적으로 k개보다 같거나 적어야하기 때문에 1에 가깝게 줄여나가는 방식임) 체크하면서
# 부족한 수량만큼 채워나감
# 부족한 수량을 채운다는 뜻은 2진법상 2^n을 더해간다는 뜻으로
# 예를 들어 n, k = 13, 1 일 때 13을 고쳐주면 1101
# 1101을 역순으로 바꾸면 1011, 제일 앞부터 체크하면 1의 위치는 idx = 0 (2진법상 2^0)
# 원본 n에 더해주면: n = 1110(14)
# 역순으로 체크하면 0111, 다시 앞부터 체크하면 1의 위치는 idx = 1 (2진법상 2^1)
# n 에 2^1을 더해주면 10000, 1의 갯수는 k와 같기 때문에 종료
# 해당 과정에서 더해준 값은 2^0, 2^1, 따라서 2^0 + 2^1 = 3
n, k = map(int, input().split())
result = 0
while True:
    if bin(n).count("1") <= k:
        print(result)
        break
    idx = bin(n)[::-1].index("1")
    current_binary = 2 ** idx
    result += current_binary
    n += current_binary
