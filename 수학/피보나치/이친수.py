# 백준 2193 이친수 문제
# dp 문제를 풀면서 항상 놓치는게 런타임에러임
# 예를 들어 dp = [0] * n, dp[0] = x, dp[1] = y 라고 작성하면 n = 1일 때 무조건 에러가 발생하는 것
# 이점에 항상 주의하자
# 규칙1. 이친수는 0으로 시작하지 않음
# 규칙2. 이친수에서는 1이 두 번 연속으로 나타나지 않음 : 1010, 1001 은 가능해도 1011 은 안 된다는것
# 1, 10, 100, 101, 1000, 1001, 1010, 10000, 10100, 10101, 10010, 10001 : 1, 1, 2, 3, 5
# 100000, 100001, 101000, 101010, 101001, 100100, 100101, 100010 : 8
# 규칙을 계산해본 결과 피보나치 수열과 동일한 것 같음

# append를 이용한 풀이1 : 첫 제출때 68ms, 두 번째는 76ms 아마 서버 상태에 따라 달라지는듯
"""
n = int(input())
dp = [1, 1]  # 한 자릿수 = 1 : 1, 두 자릿수 = 10 : 1...
for i in range(2, n):
    tmp = dp[i - 1] + dp[i - 2]
    dp.append(tmp)
print(dp[n - 1])
"""
# 치환을 이용한 풀이2 : 빠른 입력을 사용해도 76ms, 개인적인 테스트 결과에서도 메모이제이션보다도 치환을 이용한 풀이가
# 두 배 가까이 빨랐기 때문에 가급적이면 치환을 사용하자(단 문제의 유형에 맞게 다이나믹 프로그래밍이라 메모된 문제는 메모이제이션을 이용해
# 푸는게 맞는 것 같음)
n = int(input())
a, b = 0, 1
for _ in range(n):
    a, b = b, a + b  # 두 줄로 하면 이번 계산에 바로 적용되므로 2^n을 구하는 식이 된다
print(a)